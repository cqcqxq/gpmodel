"""
Some tools for working with chimera sequences generated by SCHEMA.
"""

import pandas as pd
import numpy as np
from sys import exit

def contacting_terms (sample_space, contacts):
    """ Lists the possible contacts

    Parameters:
        sample_space (iterable): Each element in sample_space contains the possible
           amino acids at that position
        contacts (iterable): Each element in contacts pairs two positions that
           are considered to be in contact

    Returns:
        contact_terms (list): Each item in the list is a contact in the form
            ((pos1,aa1),(pos2,aa2))
    """
    contact_terms = []
    for contact in contacts:
        first_pos = contact[0]
        second_pos = contact[1]
        first_possibilities = set(sample_space[first_pos])
        second_possibilities = set(sample_space[second_pos])
        for aa1 in first_possibilities:
            for aa2 in second_possibilities:
                contact_terms.append(((first_pos,aa1),(second_pos,aa2)))
    return contact_terms

def make_sequence_terms (sample_space):
    """ List the possible (pos, aa) terms.

    Parameters:
        sample_space (iterable): Each element in sample_space contains the possible
           amino acids at that position

    Returns:
         contact_terms (list): Each item in the list is a contact in the form
            ((pos1,aa1),(pos2,aa2)).
    """
    return [(i,t) for i,sp in enumerate(sample_space) for t in sp]

def make_contact_X (seqs, sample_space, contacts):
    """ Make binary indicator vector for contacts.

    Parameters:
        seqs (list): each sequence should be a string.
        sample_space (iterable): Each element in sample_space contains the possible
           amino acids at that position.
        contacts (iterable): Each element in contacts pairs two positions that
           are considered to be in contact.

    Returns:
        X (list)
        contact_terms (list): Each item in the list is a contact in the form
            ((pos1,aa1),(pos2,aa2)).
    """
    contact_X = []
    contact_terms = contacting_terms(sample_space, contacts)
    for seq in seqs:
        cons = get_contacts(seq, contacts)
        inds = [contact_terms.index(c) for c in cons]
        X_row = [1 if i in inds else 0 for i in range(len(contact_terms))]
        contact_X.append(X_row)
    return np.array(contact_X), contact_terms

def make_sequence_X(seqs, sample_space):
    """ Make binary indicator vector for sequence terms.

    Parameters:
        seqs (list): each sequence should be a string.
        sample_space (iterable): ith term should be a tuple listing the
            parental residues at the ith position.

    Returns:
        X (list)
        sequence_terms (list): Each item in the list is a term in the form
            (pos,aa).
    """
    sequence_X = []
    sequence_terms = make_sequence_terms(sample_space)
    for seq in seqs:
        this_terms = [(i,t) for i,t in enumerate(list(seq))]
        inds = [sequence_terms.index(s) for s in this_terms]
        X_row = [1 if i in inds else 0 for i in range(len(sequence_terms))]
        sequence_X.append(X_row)
    return np.array(sequence_X), sequence_terms

def make_X(seqs, sample_space, contacts):
    """ Make combined sequence/structure X.

    Combines columns that completely covary.

    Parameters:
        seqs (list): each sequence should be a string.
        sample_space (iterable): Each element in sample_space contains the possible
           amino acids at that position.
        contacts (iterable): Each element in contacts pairs two positions that
           are considered to be in contact.

    Returns:
        X (np.ndarray)
        terms (list): Each item in the list is a list of contact terms, sequence
            terms, or both.
    """
    seq_X, sequence_terms = make_sequence_X(seqs, sample_space)
    struct_X, contact_terms = make_contact_X(seqs, sample_space, contacts)
    seq_X = seq_X.tolist()
    struct_X = struct_X.tolist()
    X = [seq_X[i] + struct_X[i] for i in range(len(seqs))]
    terms = sequence_terms + contact_terms
    X = np.array(X)
    columns = [i for i in range(len(terms))]
    new_terms = []
    kept_columns = []
    while len(columns) > 0:
        current_col = columns.pop(0)
        kept_columns.append(current_col)
        current = X[:,current_col]
        duplicate_cols = [c for c in columns if
                          np.array_equal(current, X[:,c])]
        new_terms.append([terms[c] for c in [current_col] + duplicate_cols])
        for c in duplicate_cols:
            columns.remove(c)
    X = X[:, kept_columns]
    return X, new_terms

def get_contacts(seq, contacts):
    """ Gets the contacting terms for a sequence.

    Parameters:
        seq (iterable): the sequence
        contacts (iterable): each term should be a tuple listing two
            positions that are in contact with each other.

    Returns:
        contacting_terms (list): each term is of the form
            ((pos1, aa1), (pos2, aa2))
    """
    return [((con[0],seq[con[0]]),(con[1],seq[con[1]]))
              for con in contacts]

def load_assignments (assignments_file):
    """ Convert a SCHEMA assignment file to a dict mapping pos:block.

    Parameters:
        assignments_file (string)

    Returns:
        assignments (dict)
    """
    assignments_line = [l for l in open(assignments_file).read().split('\n')
                        if len(l)>0 and l[0]!='#']
    assignment = [ord(l.split('\t')[2]) - ord('A') for l in assignments_line
                  if l.split('\t')[2] !='-']
    nodes_outputfile = [int(l.split('\t')[1])-1 for l in assignments_line
                        if l.split('\t')[2] !='-'] # -1 because counting 0,1,2...
    return dict(zip(nodes_outputfile, assignment))

def make_sequence (code, assignments_dict, sample_space):
    ''' Returns the chimera sequence as a list.

    Parameters:
        sequence (iterable): original sequence
        assignments_dict (dict): dict mapping sequence position to block
        sample_space (iterable): ith term should be a tuple listing the
            parental residues at the ith position.

    Returns:
        seq (list)
    '''
    seq = []
    for pos,aa in enumerate(sample_space):
        # Figure out which parent to use at that position
        if pos in assignments_dict:
            block = assignments_dict[pos] # the assigned block (based on pos)
            # the parent for that block in this particular chimera
            parent = int(code[block])
        else:
            parent = 0
        seq.append (aa[parent])
    return seq

def substitute_blocks(sequence, blocks, assignments_dict, sample_space):
    """ Substitute chimeric blocks into a sequence.

    Parameters:
        sequence (iterable): original sequence
        blocks (iterable): each term in blocks should be tuple (p,b)
            where p is the parent id and b is the block id
        assignments_dict (dict): dict mapping sequence position to block
        sample_space (iterable): ith term should be a tuple listing the
            parental residues at the ith position.

    Returns:
        new_seq (string)
    """
    if len(sequence) != len(sample_space):
        raise ValueError('sequence and sample_space must have the same length')
    new_seq = []
    block_ids = [b for _,b in blocks]
    parent_ids = [p for p,_ in blocks]
    for i,s in enumerate(sequence):
        try:
            current_block = assignments_dict[i]
        except KeyError:
            current_block = -1
        if current_block in block_ids:
            parent = parent_ids[block_ids.index(current_block)]
            new_seq.append(sample_space[i][parent])
        else:
            new_seq.append(s)
    return ''.join(new_seq)

def make_name_dict(dict_file):
    ''' Makes the name dict from a spreadsheet

    The spreadsheet should have a 'name' column and a 'code' column.
    Names will be converted to all-lowercase. Assumes codes are 1-
    indexed and zero-indexes them.

    Parameters:
        dict_file (string): path to Excel file

    Returns:
        res (dict): maps names to chimera codes
    '''
    name_df = pd.read_excel (dict_file)
    name_df['name'] = [s.lower() for s in name_df['name']]
    new_code = [zero_index(c) for c in name_df['code']]
    name_df['code'] = new_code
    name_dict = {a:b for a,b in zip(name_df['name'], new_code)}
    return name_dict

def zero_index (code):
    '''
    Takes a 1-indexed chimera code and zero-indexes it
    '''
    return ''.join([str(int(x)-1) for x in str(code)])
